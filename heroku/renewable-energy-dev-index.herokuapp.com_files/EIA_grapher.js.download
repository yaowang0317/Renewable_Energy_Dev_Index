/**
 * EIA_grapher.js
 * version 0.6
 * Created by Mark Elbert on 3/12/15
 * U.S. Energy Information Administration
 *
 * Copyright-free redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 * THIS SOFTWARE IS PROVIDED BY THE U.S. Energy Information Administration AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intended use is to help users create interactive data visualizations
 * using real-time data from EIA's public data API
 *
 * Learn more at www.eia.gov/api/widgets.cfm
 *
 * Using the EIA API / this code requires a free API key form
 *
 * TODO:  bar and pie comparisons
 * TODO: play and pause map with xAxis plot line
 * TODO: show current date of map and bar and pie
 *
 */
'use strict';
var EIA_grapher = function(){ //single top level variable see
    var tzOffset=new Date().getTimezoneOffset()/60;
    var literals = {
        eiaVisualizationClass: 'eia-visualization',
        chartClass: 'eia_map_widget',
        mapClass: 'eia_map_widget',
        mapRelationWidthSplit: 0.69,
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        secondaryVizModes: { //enumeration of secondary visualization modes pass in via a DIV's "relation-mode" attribute.  The default mode is "pie"  
            "pie": 'pie', //requires a relation and API fetch.  Relation must be summable, else displays as bar
            "pie-comparison": 'pie-comparison',  //requires a relation and API fetch; shows a donut of first and last period returned.  Relation must be summable, else displays as "bar-comparison" mode
            "bar": 'bar',  //requires a relation and API fetch
            "bar-comparison": 'bar-comparison',  //requires a relation and API fetch; shows a donut of first and last period returned
            "line": 'line',  //relation optional: if no relation, show a line plot of the region data on mouseover. if relation show line plot of 
            "area": 'area'  //relation optional.  if relation, must be summable else degrades to "line" mode
        },
        dataset_urls: {
            PET: '/petroleum/',
            NG: '/naturalgas/',
            ELEC: '/electricity/',
            EBA: '/beta/realtime_grid',
            SEDS: '/state/seds/',
            TE: '/totalenergy',
            COAL: '/coal/',
            STEO: '/forecasts/steo/',
            AEO: '/forecasts/aeo/',
            INTL : '/countries/'
        },
        frequencies: {
            A: 365*24,
            S:  365*24/2,
            Q: 365*24/4,
            M: 30*24,
            W: 7*24,
            D: 24,
            H: 1
        },
        derivedMapDefinitions: {
            eia_elect_regions: {
                derivedFrom: "us_merc_en",
                regions: [
                    {
                        "name": "New England",
                        "code": "USA-CT+USA-MA+USA-ME+USA-NH+USA-RI+USA-VT",
                        "components": ["USA-CT","USA-ME","USA-MA","USA-NH","USA-RI","USA-VT"]
                    },
                    {
                        "name": "Middle Atlantic",
                        "code": "USA-NJ+USA-NY+USA-PA",
                        "components": ["USA-NJ","USA-NY","USA-PA"]
                    },
                    {
                        "name": "East North Central",
                        "code": "USA-IL+USA-IN+USA-MI+USA-OH+USA-WI",
                        "components": ["USA-IL","USA-IN","USA-MI","USA-OH","USA-WI"]
                    },
                    {
                        "name": "West North Central",
                        "code": "USA-IA+USA-KS+USA-MN+USA-MO+USA-ND+USA-NE+USA-SD",
                        "components": ["USA-IA","USA-KS","USA-MN","USA-MO","USA-NE","USA-ND","USA-SD"]
                    },
                    {
                        "name": "South Atlantic",
                        "code": "USA-DC+USA-DE+USA-FL+USA-GA+USA-MD+USA-NC+USA-SC+USA-VA+USA-WV",
                        "components": ["USA-DE","USA-DC","USA-FL","USA-GA","USA-MD","USA-NC","USA-SC","USA-VA","USA-WV"]
                    },
                    {
                        "name": "East South Central",
                        "code": "USA-AL+USA-KY+USA-MS+USA-TN",
                        "components": ["USA-AL","USA-KY","USA-MS","USA-TN"]
                    },
                    {
                        "name": "West South Central",
                        "code": "USA-AR+USA-LA+USA-OK+USA-TX",
                        "components": ["USA-AR","USA-LA","USA-OK","USA-TX"]
                    },
                    {
                        "name": "Mountain",
                        "code": "USA-AZ+USA-CO+USA-ID+USA-MT+USA-NM+USA-NV+USA-UT+USA-WY",
                        "components": ["USA-AZ","USA-CO","USA-ID","USA-MT","USA-NV","USA-NM","USA-UT","USA-WY"]
                    },
                    {
                        "name": "Pacific Contiguous",
                        "code": "USA-CA+USA-OR+USA-WA",
                        "components": ["USA-CA","USA-OR","USA-WA"]
                    },
                    {
                        "name": "Pacific Noncontiguous",
                        "code": "USA-AK+USA-HI",
                        "components": ["USA-AK","USA-HI"]
                    }
                ]
            },
            padds: {
                derivedFrom: "us_merc_en",
                regions: [
                    {
                        "name": "PADD I (East Coast)",
                        "code": "USA-CT+USA-DC+USA-DE+USA-FL+USA-GA+USA-MA+USA-MD+USA-ME+USA-NC+USA-NH+USA-NJ+USA-NY+USA-PA+USA-RI+USA-SC+USA-VA+USA-VT+USA-WV",
                        "components": ["USA-CT","USA-ME","USA-MA","USA-NH","USA-RI","USA-VT","USA-DE","USA-DC","USA-MD","USA-NJ","USA-NY","USA-PA","USA-FL","USA-GA","USA-NC","USA-SC","USA-VA","USA-WV"]
                    },
                    {
                        "name": "PADD II (Midwest)",
                        "code": "USA-IA+USA-IL+USA-IN+USA-KS+USA-KY+USA-MI+USA-MN+USA-MO+USA-ND+USA-NE+USA-OH+USA-OK+USA-SD+USA-TN+USA-WI",
                        "components": ["USA-IL","USA-IN","USA-IA","USA-KS","USA-KY","USA-MI","USA-MN","USA-MO","USA-NE","USA-ND","USA-SD","USA-OH","USA-OK","USA-TN","USA-WI"]
                    },
                    {
                        "name": "PADD III (Gulf Coast)",
                        "code": "USA-AL+USA-AR+USA-LA+USA-MS+USA-NM+USA-TX",
                        "components": ["USA-AL","USA-AR","USA-LA","USA-MS","USA-NM","USA-TX"]
                    },
                    {
                        "name": "PADD IV (Rocky Mountain)",
                        "code": "USA-CO+USA-ID+USA-MT+USA-UT+USA-WY",
                        "components": ["USA-CO","USA-ID","USA-MT","USA-UT","USA-WY"]
                    },
                    {
                        "name": "PADD V (West Coast)",
                        "code": "USA-AK+USA-AZ+USA-CA+USA-HI+USA-NV+USA-OR+USA-WA",
                        "components": ["USA-AK","USA-AZ","USA-CA","USA-HI","USA-NV","USA-OR","USA-WA"]
                    }
                ]
            },
            padds_sub:  {
                derivedFrom: "us_merc_en",
                regions: [
                    {
                        "name": "PADD I, Subdistrict A (New England): Connecticut, Maine, Massachusetts, New Hampshire, Rhode Island, and Vermont.",
                        "code": "USA-CT+USA-MA+USA-ME+USA-NH+USA-RI+USA-VT",
                        "components": ["USA-CT","USA-ME","USA-MA","USA-NH","USA-RI","USA-VT"]
                    },
                    {
                        "name": "PADD I, Subdistrict B (Central Atlantic): Delaware, District of Columbia, Maryland, New Jersey, New York, and Pennsylvania.",
                        "code": "USA-DC+USA-DE+USA-MD+USA-NJ+USA-NY+USA-PA",
                        "components": ["USA-DE","USA-DC","USA-MD","USA-NJ","USA-NY","USA-PA"]
                    },
                    {
                        "name": "PADD I, Subdistrict C (Lower Atlantic): Florida, Georgia, North Carolina, South Carolina, Virginia, and West Virginia.",
                        "code": "USA-FL+USA-GA+USA-NC+USA-SC+USA-VA+USA-WV",
                        "components": ["USA-FL","USA-GA","USA-NC","USA-SC","USA-VA","USA-WV"]
                    },
                    {
                        "name": "PADD II (Midwest): Illinois, Indiana, Iowa, Kansas, Kentucky, Michigan, Minnesota, Missouri, Nebraska, North Dakota, South Dakota, Ohio, Oklahoma, Tennessee, and Wisconsin.",
                        "code": "USA-IA+USA-IL+USA-IN+USA-KS+USA-KY+USA-MI+USA-MN+USA-MO+USA-ND+USA-NE+USA-OH+USA-OK+USA-SD+USA-TN+USA-WI",
                        "components": ["USA-IL","USA-IN","USA-IA","USA-KS","USA-KY","USA-MI","USA-MN","USA-MO","USA-NE","USA-ND","USA-SD","USA-OH","USA-OK","USA-TN","USA-WI"]
                    },
                    {
                        "name": "PADD III (Gulf Coast): Alabama, Arkansas, Louisiana, Mississippi, New Mexico, and Texas",
                        "code": "USA-AL+USA-AR+USA-LA+USA-MS+USA-NM+USA-TX",
                        "components": ["USA-AL","USA-AR","USA-LA","USA-MS","USA-NM","USA-TX"]
                    },
                    {
                        "name": "PADD IV (Rocky Mountain): Colorado, Idaho, Montana, Utah, and Wyoming.",
                        "code": "USA-CO+USA-ID+USA-MT+USA-UT+USA-WY",
                        "components": ["USA-CO","USA-ID","USA-MT","USA-UT","USA-WY"]
                    },
                    {
                        "name": "PADD V (West Coast): Alaska, Arizona, California, Hawaii, Nevada, Oregon, and Washington.",
                        "code": "USA-AK+USA-AZ+USA-CA+USA-HI+USA-NV+USA-OR+USA-WA",
                        "components": ["USA-AK","USA-AZ","USA-CA","USA-HI","USA-NV","USA-OR","USA-WA"]
                    }
                ]
            },
            world: {
                derivedFrom: "world_mill_en",
                regions: [
                    {
                        "name": "Sudan and South Sudan",
                        "code": "SDN+SSD",
                        "components": ["SDN","SSD"]
                    }
                ]
            },
            world_regions: {
                derivedFrom: "world_mill_en",
                regions: [
                    {
                        "name": "Africa",
                        "code": "AGO+BDI+BEN+BFA+BWA+CAF+CIV+CMR+COD+COG+COM+CPV+DJI+DZA+EGY+ERI+ESH+ETH+GAB+GHA+GIN+GMB+GNB+GNQ+KEN+LBR+LBY+LSO+MAR+MDG+MLI+MOZ+MRT+MUS+MWI+NAM+NER+NGA+REU+RWA+SDN+SEN+SHN+SLE+SOM+STP+SWZ+SYC+TCD+TGO+TUN+TZA+UGA+ZAF+ZMB+ZWE",
                        "components": ["AGO","BDI","BEN","BFA","BWA","CAF","CIV","CMR","COD","COG","COM","CPV","DJI","DZA","EGY","ERI","ESH","ETH","GAB","GHA","GIN","GMB","GNB","GNQ","KEN","LBR","LBY","LSO","MAR","MDG","MLI","MOZ","MRT","MUS","MWI","NAM","NER","NGA","REU","RWA","SDN","SEN","SHN","SLE","SOM","STP","SWZ","SYC","TCD","TGO","TUN","TZA","UGA","ZAF","ZMB","ZWE", "SSD"] //include South Sudan
                    },
                    {
                        "name": "Asia & Oceania",
                        "code": "AFG+ASM+AUS+BGD+BRN+BTN+CHN+COK+FJI+FSM+GUM+HITZ+HKG+IDN+IND+JPN+KHM+KIR+KOR+LAO+LKA+MAC+MDV+MMR+MNG+MYS+NCL+NIU+NPL+NRU+NZL+PAK+PHL+PNG+PRK+PYF+SGP+SLB+THA+TLS+TON+TUV+TWN+USIQ+VNM+VUT+WAK+WSM",
                        "components": ["AFG","ASM","AUS","BGD","BRN","BTN","CHN","COK","FJI","FSM","GUM","HITZ","HKG","IDN","IND","JPN","KHM","KIR","KOR","LAO","LKA","MAC","MDV","MMR","MNG","MYS","NCL","NIU","NPL","NRU","NZL","PAK","PHL","PNG","PRK","PYF","SGP","SLB","THA","TLS","TON","TUV","TWN","USIQ","VNM","VUT","WAK","WSM"]
                    },
                    {
                        "name": "Central & South America",
                        "code": "ABW+ARG+ATA+ATG+BHS+BLZ+BOL+BRA+BRB+CHL+COL+CRI+CUB+CYM+DMA+DOM+ECU+FLK+GLP+GRD+GTM+GUF+GUY+HND+HTI+JAM+KNA+LCA+MSR+MTQ+NIC+NLDA+PAN+PER+PRI+PRY+SLV+SUR+TCA+TTO+URY+VCT+VEN+VGB+VIR",
                        "components": ["ABW","ARG","ATA","ATG","BHS","BLZ","BOL","BRA","BRB","CHL","COL","CRI","CUB","CYM","DMA","DOM","ECU","FLK","GLP","GRD","GTM","GUF","GUY","HND","HTI","JAM","KNA","LCA","MSR","MTQ","NIC","NLDA","PAN","PER","PRI","PRY","SLV","SUR","TCA","TTO","URY","VCT","VEN","VGB","VIR"]
                    },
                    {
                        "name": "Eurasia",
                        "code": "ARM+AZE+BLR+EST+GEO+KAZ+KGZ+LTU+LVA+MDA+RUS+SUN+TJK+TKM+UKR+UZB",
                        "components": ["ARM","AZE","BLR","EST","GEO","KAZ","KGZ","LTU","LVA","MDA","RUS","SUN","TJK","TKM","UKR","UZB"]
                    },
                    {
                        "name": "Europe",
                        "code": "ALB+AUT+BEL+BGR+BIH+CHE+CSK+CYP+CZE+DDR+DEU+DEUW+DNK+ESP+FIN+FRA+FRO+GBR+GIB+GRC+HRV+HUN+IRL+ISL+ITA+LUX+MKD+MLT+MNE+NLD+NOR+POL+PRT+ROU+SCG+SRB+SVK+SVN+SWE+TUR+UNK+YUG",
                        "components": ["ALB","AUT","BEL","BGR","BIH","CHE","CSK","CYP","CZE","DDR","DEU","DEUW","DNK","ESP","FIN","FRA","FRO","GBR","GIB","GRC","HRV","HUN","IRL","ISL","ITA","LUX","MKD","MLT","MNE","NLD","NOR","POL","PRT","ROU","SCG","SRB","SVK","SVN","SWE","TUR","UNK","YUG"]
                    },
                    {
                        "name": "Middle East",
                        "code": "ARE+BHR+IRN+IRQ+ISR+JOR+KWT+LBN+OMN+PSE+QAT+SAU+SYR+YEM",
                        "components": ["ARE","BHR","IRN","IRQ","ISR","JOR","KWT","LBN","OMN","PSE","QAT","SAU","SYR","YEM"]
                    },
                    {
                        "name": "North America",
                        "code": "BMU+CAN+GRL+MEX+SPM+USA",
                        "components": ["BMU","CAN","GRL","MEX","SPM","USA"]
                    }
                ]
            }
        },
        bubbleCenterExceptions: {  //these are exception for countries and regions whose bounding boxes are thrown off by overseas territories and such
            "USA": [39.539089,-97.928757],
            "USA-CA": [35.536533, -120.375571],
            "USA-FL": [27.885471,-81.420250],
            "USA-MA": [42.407443, -71.101889],
            "USA-MI": [44.324050, -84.856772],
            "NOR": [60.550137, 7.697115],
            "SWE": [59.451651, 16.266451],
            "RUS": [63.923745, 57.223488],
            "FRA": [47.258188, 2.028176]
        }
    };
    var nonWordPat = /[^\w)]/; // compiled once instead of local var in _categoriesFromSeries
    var drawAllVisualizations = function(){
        $('div.'+literals.eiaVisualizationClass).each(function(i, $vizDiv){drawDivVisualization($vizDiv)});
    };
    function drawDivVisualization(vizDiv){
        //creates an interactive visualization in the <DIV> $vizDiv, based on the tag's HTML attributes
        var $vizDiv = $(vizDiv),
            map = $vizDiv.attr("map"),
            title = $vizDiv.attr("title"),
            geoset_id = $vizDiv.attr("geoset_id"),
            cube_id = $vizDiv.attr("cube_id"),
            start = $vizDiv.attr("start"),
            end = $vizDiv.attr("end"),
            num = $vizDiv.attr("num"),
            periods = $vizDiv.attr("periods"),
            analysis = $vizDiv.attr("analysis"),
            series_id = $vizDiv.attr("series_id"),
            regions = $vizDiv.attr("regions"),
            relation_id = $vizDiv.attr("relation_id"),
            relation_mode = $vizDiv.attr("relation_mode"),
            chartOptions,
            $jmap;  //closure variable of jVectorMap after instantiation
			
		if(analysis === undefined) { analysis = 'none';}


        if(regions) regions = regions.split(';');  //regions is a list if provided

        //depending on tag attributes (map, geoset_id, relation_id, relation_mode, & tracking_regions), create a:
        // A. map-relation chart interactive
        // B. map
        // C. series chart,
        // D. relation chart (without an accompanying map)
        if(map&&geoset_id) {
            //either (A) or (B): either way we have a map
            var $mapDiv, $relationDiv, relationChart = false, vectorMap;
            //create component <DIV> as necessary for a map-relation chart interactive
            if(relation_id || relation_mode== literals.secondaryVizModes.line || relation_mode == literals.secondaryVizModes.area){
                // A. map-relation chart interactive!!
                var totalWidth = $vizDiv.width();  //create a 60% - 40% map / chart split
                var divHeight = $vizDiv.innerHeight();  //need to apply height to inner divs

                $vizDiv.html('<div class="EIA_relation" style="float: right;width: '+parseInt(totalWidth*(1-literals.mapRelationWidthSplit-0.01))+'px;"></div><div class="EIA_map" style="display:inline-block;width: '+(100*literals.mapRelationWidthSplit)+'%;position: relative"></div>')
                $mapDiv = $vizDiv.find('.EIA_map').height(divHeight);
                $relationDiv = $vizDiv.find('.EIA_relation').height(divHeight);
            } else {
                // B. map (solo without secondary visualization)
                $mapDiv = $vizDiv;
            }

            //call makeMapOptions to make the mapOptions object.  If secondary visualization, create the chart and map events to link the map to the chart
            makeMapOptions(
                _buildInteractiveMapChart,
                map,
                geoset_id,
                regions,
                start,
                end,
                num,
                analysis,
                periods
            );
            return true;
        } else {
            if(series_id) {
                // C. series chart,
                chartOptions = makeHighchartForSeries(
                    $vizDiv,
                    title,
                    series_id,
                    start,
                    end,
                    num,
                    relation_mode,
                    analysis,
                    periods
                );
            } else {
                // D. relation chart (without an accompanying map)
                if(relation_id){ //solo relationship chart without an accompanying interactive map
                    makeRelationChartOptions(
                        function(chartOptions){
                            publicMethods.visualizationReady($vizDiv, chartOptions.relation, 'primary_relation', chartOptions);
                            $vizDiv.highcharts(chartOptions);
                        },
                        $vizDiv,
                        relation_id,
                        regions,
                        start,
                        end,
                        num,
                        relation_mode,
                        null,
                        periods
                    );
                }
            }
        }

        function _buildInteractiveMapChart(mapOptions){
            //this is the callback function after makeMapOptions fetches the geoset data and create a jVectormap mapOptions object
            if(relation_id){
                mapOptions.regionsSelectable = true; //default is false
                mapOptions.regionsSelectableOne = true;
                //1. create the relation chart (secondary viz) using the Highchart charting library

                //bars, pies and donuts do not have datetime axis, but add one for line or area mode
                if(regions){
                    makeRelationChartOptions(function(chartOptions){
                            chartOptions.chart.renderTo = $relationDiv.get(0);
                            publicMethods.visualizationReady($relationDiv, chartOptions.relation, 'relation', chartOptions);
                            relationChart = new Highcharts.Chart(chartOptions)
                        },
                        $relationDiv,
                        relation_id,
                        regions[0],
                        start,
                        end,
                        num,
                        relation_mode,
                        mapOptions,
                        periods
                    );
                } else {
                    var relationChartOptions =  {
                        chart: {
                            renderTo: $relationDiv.get(0),
                            type: relation_mode
                        },
                        credits : {
                            href : _linkBackUrl(geoset_id),
                            style: {
                                color: '#0096d7',
                                textDecoration: 'underline'
                            }
                        },
                        title: {
                            text: 'click a region to show details'
                        },
                        series: [],
                        yAxis: {
                            title: {
                                text: mapOptions.geosetData.units
                            }
                        }
                    };
                    if(relation_mode=='line'||relation_mode=='area') {
                        relationChartOptions.xAxis = {type: 'datetime'};
                    }
                    publicMethods.visualizationReady($relationDiv, mapOptions.geosetData, 'relation', chartOptions);
                    relationChart = new Highcharts.Chart(relationChartOptions);
                }

                //2. add the onRegion click event handler
                mapOptions.onRegionClick = function(event, regionCode){
                    if(mapOptions.geosetData && mapOptions.geosetData.series[regionCode]){
                        if(relationChart) relationChart.destroy();
                        makeRelationChartOptions(function(chartOptions){
                                chartOptions.chart.renderTo = $relationDiv.get(0);
                                publicMethods.visualizationReady($relationDiv, chartOptions.relation, 'relation', chartOptions);
                                relationChart = new Highcharts.Chart(chartOptions)
                            },
                            $relationDiv,
                            relation_id,
                            regionCode,
                            start,
                            end,
                            num,
                            relation_mode,
                            mapOptions,
                            periods
                        );
                    }

                    return true;
                };
                mapOptions.onMarkerClick = function(event, regionCode){
                    $jmap.clearSelectedRegions();
                    $jmap.setSelectedRegions(regionCode);
                    mapOptions.onRegionClick(event, regionCode);

                    return true;
                }
            } else {
                if(relation_mode== literals.secondaryVizModes.line || relation_mode == literals.secondaryVizModes.area){
                    //auto viz form map data
                    //1. create Highchart
                    var thisMapsSelectedRegions = [];
                    var relationChartOptions =  {
                        chart: {
                            renderTo: $relationDiv.get(0),
                            type: relation_mode  //supports line or area modes (area can only be used to display a single series)
                        },
                        credits : {
                            href : _linkBackUrl(geoset_id),
                            style: {
                                color: '#0096d7',
                                textDecoration: 'underline'
                            }
                        },
                        lang: {
                            noData: "click on regions<br> to compare history"
                        },
                        title: {
                            text: 'click map to select',
                            style: {
                                "fontSize": "12px",
                                color: '#555555'
                            }
                        },
                        series: [],
                        xAxis: {
                            type: 'datetime'
                        },
                        yAxis: {
                            title: {
                                text: mapOptions.geosetData.units
                            }
                        },
                        tooltip: {
                            useHTML: true,
                            formatter: function(){
                                var d = new Date(this.x||0),
                                    seriesLine = this.series.name + (this.x?' in ' + readableDateFromUtcDate(d, mapOptions.geosetData.f):'') + ':',
                                    value = Highcharts.numberFormat(Math.abs(this.point.y), 0) + ' ' + mapOptions.geosetData.units,
                                    chartWidth = $(this.series.chart.container).width();
                                return _breakInsert(seriesLine, chartWidth)
                                    +'<br/>'
                                    + _breakInsert(value, chartWidth);
                            }
                        }
                    };
                    publicMethods.visualizationReady($relationDiv, mapOptions.geosetData, 'relation', chartOptions);
                    relationChart = new Highcharts.Chart(relationChartOptions);

                    //2. add the onRegion mouseover event handler
                    mapOptions.onRegionOver = function(event, regionCode){
                        if(mapOptions.geosetData && mapOptions.geosetData.series[regionCode]){
                            _removeUnselectedUntrackedLines();
                            relationChart.setTitle({text: 'click map to select'}); //mapOptions.geosetData.setName});  //add a title and remove the subtitle = the call to click/mouse over
                            if(!relationChart.get(regionCode)) _showRegionSeries(relationChart, mapOptions.geosetData, regionCode);
                            relationChart.yAxis[0].userMax = null;  //Highcharts bugs when lots on mouseover fire, it sometimes gets confused and sets and then rescaling no longer works correctly
                            relationChart.redraw();
                        }
                    };
                    mapOptions.onRegionOut = function(event, regionCode){
                        _removeUnselectedUntrackedLines();
                        relationChart.redraw();
                    };
                    //3. if line mode (not area mode!), enable "stick on click" comparisons
                    if(relation_mode== literals.secondaryVizModes.line){
                        mapOptions.regionsSelectable = true; //default is false
                        mapOptions.regionsSelectableOne = false;
                        //mapOptions.markersSelectable = true; //default is false
                        //mapOptions.markersSelectableOne = false;
                        mapOptions.onRegionSelected = function(event, regionCode,  isSelected, selectedRegions){
                            if(!isSelected&&thisMapsSelectedRegions.indexOf(regionCode)>=0)
                                thisMapsSelectedRegions.splice(thisMapsSelectedRegions.indexOf(regionCode),1);
                            else if(isSelected&&thisMapsSelectedRegions.indexOf(regionCode)<0)
                                thisMapsSelectedRegions.push(regionCode);

                            _removeUnselectedUntrackedLines();
                            if(isSelected && !relationChart.get(regionCode)) _showRegionSeries(relationChart, mapOptions.geosetData, regionCode);
                            relationChart.redraw();
                        };
                        mapOptions.onMarkerClick = function(event, code){
                            var currentlySelectedRegions = $jmap.getSelectedRegions(),
                                found = false,
                                newRegionSelection = {};

                            for(var r=0; r < currentlySelectedRegions.length; r++){
                                if(currentlySelectedRegions[r] == code){
                                    found = true;
                                    //selectedRegions.splice(r,1);
                                    newRegionSelection[currentlySelectedRegions[r]] = false;
                                } else {
                                    newRegionSelection[currentlySelectedRegions[r]] = true;
                                }
                            }
                            if(!found) newRegionSelection[code] = true;
                            $jmap.setSelectedRegions(newRegionSelection);

                            return true;
                        }
                    }
                }
            }
            publicMethods.visualizationReady($mapDiv, mapOptions.geosetData, 'map', mapOptions);

            //add the marker config to the mapoptions object (cannot be in _mapOptions because the we need $mapDiv to get calculate the display area (to set the bubble radius)
            if(analysis=='bubble'){
                var maxValue = 0,
                    bubbleCount = 0;
                for(var code in jvm.Map.maps[map].paths){
                    if(mapOptions.series.regions[0].values[code]){
                        maxValue = Math.max(maxValue, mapOptions.series.regions[0].values[code]);
                        bubbleCount++;
                    }
                }
                var mapDivArea = $mapDiv.width() * $mapDiv.height();
                mapOptions.series.markers = [{
                    attribute: 'r',
                    scale: [0, parseInt(Math.sqrt(Math.sqrt(mapDivArea/bubbleCount) * 2))],
                    min: 0,
                    max: maxValue,
                    normalizeFunction: function(val){
                        return (!isNaN(val) && val>0) ? Math.sqrt(val) : 0;
                    }
                }];
                //delegate the marker events to the existing region events
                mapOptions.onMarkerOver = mapOptions.onRegionOver;
                //mapOptions.onMarkerClick = mapOptions.onRegionClick;
                mapOptions.onMarkerOut = mapOptions.onRegionOut;
                mapOptions.onMarkerTipShow = mapOptions.onRegionTipShow;

            }



            $mapDiv.vectorMap(mapOptions);

            $jmap = $mapDiv.vectorMap('get', 'mapObject');
            //select the initial regions for non-relationship maps
            if(!relation_id && regions){
                if(regions.length){
                    var parsedRegions=[];

                    thisMapsSelectedRegions = regions;
                    for(var x=0;x<regions.length;x++){
                        _showRegionSeries(relationChart, mapOptions.geosetData, regions[x]);
                        if(typeof jvm.Map.maps[map].paths[regions[x]] !== 'undefined')
                            parsedRegions.push(regions[x]);
                    }
                    relationChart.redraw();

                    $jmap.setSelectedRegions(parsedRegions);
                }
            }

            //create markers if analysis = bubble (cannot be in _mapOptions because the jVectorMap must be created to use pointToLatLng() and getBBox()
            if(analysis=='bubble'){
                var markers = {};
                for(var code in jvm.Map.maps[map].paths){
                    if(mapOptions.series.regions[0].values[code]){
                        if(literals.bubbleCenterExceptions[code]){
                            var exception = literals.bubbleCenterExceptions[code];
                            latLng = {lat: exception[0], lng: exception[1]}
                        } else {
                            var svg = $mapDiv.find('path.jvectormap-region[data-code=\''+ code +'\']').get(0),
                                bBox = svg.getBBox(),
                                xCenter = (bBox.x + bBox.width/2 + $jmap.transX) * $jmap.scale,
                                yCenter = (bBox.y + bBox.height/2 + $jmap.transY) * $jmap.scale,
                                latLng = $jmap.pointToLatLng(xCenter, yCenter);
                        }
                        markers[code] = {
                            key: code,
                            latLng: [latLng.lat, latLng.lng],
                            //val: mapOptions.series.regions[0].values[code],
                            name: jvm.Map.maps[map].paths[code].name
                        };

                    }

                }
                $jmap.addMarkers(markers);
                $jmap.series.markers[0].max = maxValue;
                $jmap.series.markers[0].setValues(mapOptions.series.regions[0].values);
            }

            //add the map title
            $mapDiv.prepend('<span class="EIA-map-title"></span>')
                .find('.EIA-map-title').html((title||mapOptions.title) + (mapOptions.subtitle? '<br>' + mapOptions.subtitle : ''));

            function _removeUnselectedUntrackedLines(){
                var i, hcSerie;
                for(i=0;i<relationChart.series.length;i++){
                    hcSerie = relationChart.series[i];
                    if(thisMapsSelectedRegions.indexOf(hcSerie.options.id)===-1/* && (!regions || regions.indexOf(hcSerie.options.id)===-1)*/) hcSerie.remove(false);
                }
            }
        }
    }

    function makeHighchartForSeries($vizDiv, title, series_id, start, end, num, mode, analysis, periods){
        if(window.Highcharts){
            var params = {command: 'series', series_id: series_id};
            if(start) params.start = start;
            if(end) params.end = end;
            if(num) params.num = num;
            if(periods) params.periods = periods;
			
            callAPI(params, _callBack);
        } else {
            throw "no supported charting package (Highcharts) detected."
        }

        function _callBack(jsoData){
			var tz = new Date().toString().match(/\(([A-Za-z\s].*)\)/)[1];
            var i,
                eiaSerie,
                unitsToAxis = {},
                highchartOptions = {
                    eia_start: start,
                    eia_end: end,
                    eia_num: num,
                    eia_periods: periods,
                    series: [],
                    yAxis: [],
                    xAxis: {
                        type: 'datetime'
                    },
                    title: {text: ''},
                    credits: {
                        href: _linkBackUrl(series_id),
                        style: {
                            color: '#0096d7',
                            textDecoration: 'underline'
                        }
                    },
					timezone: tz
                };

            if(title) {
                highchartOptions.title = {text: title};
            } else {
                highchartOptions.title = {text: _categoriesFromSeries(jsoData.series)};
            }

            var common_start_UTC = false;  //required for analysis
            for(i=0;i<jsoData.series.length;i++){
                eiaSerie = jsoData.series[i];

                if(typeof(unitsToAxis[eiaSerie.units.toUpperCase()]) == 'undefined'){
                    unitsToAxis[eiaSerie.units.toUpperCase()] = highchartOptions.yAxis.length;
                    highchartOptions.yAxis.push({
                        title: {text: eiaSerie.units},
                        opposite: unitsToAxis[eiaSerie.units.toUpperCase()] % 2 == 1
                    });
                }
                var hcSerie = {
                    eia_series_id: eiaSerie.series_id,
                    data: parseEiaTimeSeriesData(eiaSerie.data),
                    name: eiaSerie.categoryName || eiaSerie.name,
                    seriesName: eiaSerie.name,
                    step: eiaSerie.f == 'H',
                    source: eiaSerie.source,
                    yAxis: unitsToAxis[eiaSerie.units.toUpperCase()]
                };

                if(analysis != 'none'){  //make sure that we have a common start date if trying to calculate growth
                    if(hcSerie.data.length > 0){
                        hcSerie.firstVal = hcSerie.data[0][1];
                        if(i==0 && (hcSerie.firstVal || hcSeries.firstVal === 0) && !isNaN(hcSerie.firstVal)){
                            common_start_UTC = hcSerie.data[0][0];
                        } else {
                            if(common_start_UTC !== hcSerie.data[0][0] || !(hcSerie.firstVal || hcSeries.firstVal === 0) || isNaN(hcSerie.firstVal)) {
                                common_start_UTC = false;
                            }
                        }
                    }
                }
                if(eiaSerie.f == 'H') {
                    var now = new Date();
                    Highcharts.setOptions({global: {timezoneOffset: now.getTimezoneOffset()}});
                }
                if(eiaSerie.copyright == 'Thomson-Reuters') highchartOptions.chart = {logo: 2};  //used by the EIA HC theme
                if(eiaSerie.copyright == 'Bloomberg') highchartOptions.chart = {logo: 3};

                if(typeof eiaSerie.lastHistoricalPeriod !== 'undefined')
                    hcSerie.lastHistoricalPeriod = eiaSerie.lastHistoricalPeriod;

                highchartOptions.series.push(hcSerie);
            }

            //calculate indexed values, modify yAxes, and add subtitles
            if((analysis=="indexval" ||analysis=="indexpct") && common_start_UTC !== false){
                common_start_UTC = new Date(common_start_UTC);  //Highchart uses the getTime() bigint value, whereas readableDateFromUtcDate needs a Date
                //add subtitle
                highchartOptions.subtitle = {text: 'Change from ' + readableDateFromUtcDate(common_start_UTC, eiaSerie.f)};
                if(analysis=="indexpct") {
                    //replace the yAxes with a single unified yAxis
                    highchartOptions.yAxis = [{
                        title: {text: 'percent'}
                    }]
                }
                //if(analysis=="indexval") highchartOptions.subtitle = {text: 'Indexed to ' + readableDateFromUtcDate(common_start_UTC, eiaSerie.f) + ' as value'};

                //recalculate the values
                for(i=0;i<highchartOptions.series.length;i++){
                    if(analysis=="indexpct") highchartOptions.series[i].yAxis = 0;
                    var decimals=0; //reset only for new series
                    for(var j=0;j<highchartOptions.series[i].data.length;j++){
                        if(isNaN(highchartOptions.series[i].data[j][1])) {
                            highchartOptions.series[i].data[j][1] = null;
                        }
                        if(analysis=="indexval") {
                            for(;decimals<10;decimals++){ //JavaScript floating point subtraction adds artifacts.  This routine maintains the precision of the source data.
                                if(highchartOptions.series[i].data[j][1]==highchartOptions.series[i].data[j][1].toFixed(decimals)  && highchartOptions.series[i].firstVal==highchartOptions.series[i].firstVal.toFixed(decimals)){
                                    break;
                                }
                            }
                            highchartOptions.series[i].data[j][1] = parseFloat((highchartOptions.series[i].data[j][1] - highchartOptions.series[i].firstVal).toFixed(decimals));
                        }
                        else if(analysis=="indexpct") {
                            highchartOptions.series[i].data[j][1] = Math.round(100*(highchartOptions.series[i].data[j][1]/highchartOptions.series[i].firstVal - 1))/100;  //display only 2 digits places after the decimal point
                        }
                    }
                }
            }
            else { // handle non-numeric values
                for(i=0;i<highchartOptions.series.length;i++) {
                    for (var j = 0; j < highchartOptions.series[i].data.length; j++) {
                        if (isNaN(highchartOptions.series[i].data[j][1])) {
                            highchartOptions.series[i].data[j][1] = null;
                        }
                    }
                }
            }

            publicMethods.visualizationReady($vizDiv, jsoData, 'graph', highchartOptions);
            $vizDiv.highcharts(highchartOptions);
            return highchartOptions;
        }
    }

    function makeRelationChartOptions(callback, $relationDiv, relation_id, regionCode, start, end, num, secondaryVizMode, mapOptions, periods){
        //if no "date" passed in, use latest in data series
        //if no "secondaryVizMode" passed in, use relation.issummable to choose between pie and bar.  Note: area|pie short to line|bar if relationship is not summable;
        var apiParams = {
            command: 'relation',
            relation_id: relation_id,
            region: regionCode
        };
        var date;
        if(start) apiParams.start = start;
        if(end) apiParams.end = end;
        if(num) apiParams.num = num;
        if(periods) apiParams.periods = periods;
        if(secondaryVizMode == literals.secondaryVizModes.bar  || secondaryVizMode == literals.secondaryVizModes.pie){ //just a single point is needed
            if(!start) {
                apiParams.num = 1;
            } else {
                apiParams.end = start;
                date = start;
            }
        }
        var relationKey = relation_id+'|'+regionCode+'|'+ (start||1);
        if(EIA_grapher.data.relations[relationKey]){
            callback(_relChartOptions());
        }
        callAPI(apiParams, function(eiaData, textStatus, jqXHR){
            if(!eiaData.relation) throw 'unable to fetch data for relation_id='+relation_id+' and region='+regionCode;
            EIA_grapher.data.relations[relationKey] = eiaData.relation;
            callback(_relChartOptions());
        });
        function _relChartOptions(){
            //1. detect order no longer possible (it complicated!)
            //2. find geoName from assets geoKey
            var relation = EIA_grapher.data.relations[relationKey];
            var relationSeries = relation.series, i;
            _categoriesFromSeries(relationSeries); //make usable category names
            var type;
            switch(secondaryVizMode||'pie'){ //if undefined, try to do a pie (degrades automatically to bar if not summable
                case 'pie':
                case 'pie-comparison':
                    type = (relation.stack_facets != null) ? 'bar' : relation.summable?'pie':'bar';
                    break;
                case 'bar':
                case 'bar-comparison':
                    type = 'bar';
                    break;
                case 'area':
                    type = ((relation.stack_facets == null) ? (relation.summable?'area':'line') : 'bar'); //2D relations can only be a bar
                    break;
                case 'line':
                    type = 'line';
                    break;
            }

            relation.hasData = false;
            for(i=0;i<relationSeries.length;i++){
                if(relationSeries[i].data){
                    relation.hasData = true;
                    if(relationSeries[i].stack_facets != null) type = 'bar'; //override for 2D relation
                    break;
                }
            }
            var title;
            if(mapOptions){
                var titles = [{name: mapOptions.title}, {name: relation.vertexname}];
                _categoriesFromSeries(titles);
                title = titles[1].categoryName;
            } else {
                //title = relation.vertexname;
                title=_categoriesFromSeries(relation.series);
            }
            var chartWidth = $relationDiv.width(),
                chartHeight = $relationDiv.height();
            //3. make base chart options object
            var relationHighChartOptions = {
                chart: {
                    type: type,
                    relation_id: relation_id,
                    date: date
                },
                credits : {
                    href : _linkBackUrl(relation_id),
                    style: {
                        color: '#0096d7',
                        textDecoration: 'underline'
                    }
                },
                relation: relation, //stash a reference to the fetched data object
                title: {
                    text: chartWidth? _breakInsert(title, chartWidth) : title,
                    style: {fontSize: '12px'},
                    align: 'center'
                },
                plotOptions: {
                    bar: {
                        dataLabels: {
                            enabled: false,
                            align: 'left',
                            formatter: function(){
                                return relation.hasData?(this.y===null?"no data":this.y):'';
                            }
                        },
                        borderWidth: 0,
                        animation: false,
                        stacking: 'normal'
                    },
                    pie: {
                        cursor: 'pointer',
                        showInLegend: true,
                        dataLabels: {
                            enabled: true,
                            format: '{point.percentage:.1f}%', //had value and units but size was a problem even with line breaks: {point.y}<br>'+relation.units+'<br>
                            style: {
                                color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black'
                            }
                        }
                    },
                    area: {
                        stacking: 'normal'
                    }
                },
                xAxis: {
                    categories: [],
                    title: {
                        text: null
                    },
                    lineWidth: 1,
                    //minorGridLineWidth: 0,
                    //minorTickLength: 0,
                    //tickLength: 0,
                    labels: {
                        enabled: true
                    }
                },
                yAxis: {
                    title: {
                        text:  relation.units||relation.series[0].units
                    }
                    /*labels: {
                     enabled: false
                     },
                     lineWidth: 0,
                     minorGridLineWidth: 0,
                     lineColor: 'transparent',
                     gridLineColor: 'transparent',
                     gridLineWidth: 0*/
                },
                //not the cause of the right margin problem: exporting: false
                legend: {
                    floating: false,
                    borderWidth: 0,
                    maxHeight: parseInt(chartHeight * 0.25),
                    labelFormatter: function () {
                        return _breakInsert(this.name||this.seriesName, $((this.chart && this.chart.container) || this.series.chart.container).width());
                    }
                },
                series: [],
                tooltip: {
                    useHTML: true,
                    formatter: function(){
                        var d = new Date(this.x||0),
                            seriesLine = this.point.seriesName||this.point.name||this.series.name + (this.x?' in ' + readableDateFromUtcDate(d, relation.f):'') + ':',
                            value = Highcharts.numberFormat(Math.abs(this.point.y), 0) + ' ' + relation.units,
                            chartWidth = $(this.series.chart.container).width();
                        return _breakInsert(seriesLine, chartWidth)
                            +'<br/>'
                            + _breakInsert(value, chartWidth);
                    }
                }
            };
            //4. loop through the relationSeries (note:  setdata must be left outer joined to cubecompents to produce NULL placeholders when missing for certain geographies)
            var point,
                y,
                barOrder,
                stackOrder,
                data = [],
                barFacets  = (relation.bar_facets)?JSON.parse(relation.bar_facets):[],
                stackFacets  = (relation.stack_facets)?JSON.parse(relation.stack_facets):null;
            if(type=='line' || type=='area'){
                //4A. line and area = time series
                relationHighChartOptions.xAxis.type = 'datetime';
                delete  relationHighChartOptions.xAxis.categories;
                for(i=0;i<relationSeries.length;i++){
                    relationHighChartOptions.series.push({
                        data: parseEiaTimeSeriesData(relationSeries[i].data),
                        id: relationSeries[i].series_id,
                        name: _breakInsert(relationSeries[i].categoryName || relationSeries[i].name || ('no data for '+barFacets[i]), chartWidth)
                    });
                }
            } else {
                //4B. pies, bars, and stacked bars
                for(i=0;i<relationSeries.length;i++){
                    barOrder =  parseInt(relationSeries[i].bar_order);
                    stackOrder = parseInt(relationSeries[i].stack_order);
                    y = _seriesValue(relationSeries[i].data, date);
                    if(y === undefined) y = 0;
                    if(y===null && relationHighChartOptions.chart.type=='pie') relationHighChartOptions.chart.type = 'bar'; //degrade to bar if a component of a pie chart is missing
                    if(y!==null && !date) date = relationSeries[i].data[0][0];
                    point = {
                        y:  y,
                        name: relationSeries[i].categoryName || 'no data for '+ barFacets[barOrder],
                        seriesName: relationSeries[i].name || 'series does not exist'
                    };
                    data.push(point);
                    if(barOrder == (barFacets.length-1)) {  //barorder and stackorder are 0-based (-1 is used to denote non-exist stack)
                        var serie = {data: data};
                        if(stackFacets) {
                            serie.name = stackFacets[stackOrder];
                        } else {
                            if(relationHighChartOptions.chart.type=='bar') serie.showInLegend = false;  //bars already have category labels
                            //TODO: use geography name when multiple regions are displayed together via CNTL+click action
                        }
                        relationHighChartOptions.series.push(serie);
                        data = [];
                    }
                }
                //add the categories
                for(i=0;i<barFacets.length;i++){
                    relationHighChartOptions.xAxis.categories.push(barFacets[i]);
                }
                //add the date to the subtitle
                if(relationHighChartOptions.title.text.length)
                    relationHighChartOptions.title.text+=" - "+readableDateFromEiaDate(date, relation['f']);
                if(!stackFacets){
                    relationHighChartOptions.plotOptions.bar.dataLabels.enabled = true;
                }
                if(relationHighChartOptions.chart.type=='pie') delete relationHighChartOptions.yAxis;  //trying to save room (not the cause of the right margin problem, nor is exporting)
            }
            return relationHighChartOptions;
        }
    }
    function makeMapOptions(callback, map, geoset_id, regions, start, end, num, analysis, periods){
        if(!window.jvm) throw "jVectorMaps not loaded";
        if(!jvm.Map.maps[map]){
            if(!literals.derivedMapDefinitions[map]) {
                throw 'map '+ map + ' is not loaded or defined';
            } else {
                if(!jvm.Map.maps[literals.derivedMapDefinitions[map].derivedFrom]) throw 'map '+map+' is derived from '+literals.derivedMapDefinitions[map].derivedFrom+', which is not loaded';
                _makeMap(map);
            }
        }
        var mapPaths = jvm.Map.maps[map].paths, requestedRegions = [];
        for(var path in mapPaths){
            requestedRegions.push(path);
        }
        if(regions) requestedRegions = requestedRegions.concat(regions);
        var setKey = geoset_id+':'+map;
        if(!EIA_grapher.data.geosets[setKey]){
            var apiParams = {
                command: 'geoset',
                geoset_id: geoset_id,
                regions: requestedRegions.join(';')
            };
            if(num) apiParams.num = num;
            if(start) apiParams.start = start;
            if(end) apiParams.end = end;
            if(periods) apiParams.periods = periods;
            callAPI(apiParams, function(eiaData, textStatus, jqXHR){
                if(!eiaData.geoset) throw 'unable to fetch data for geoset_id='+geoset_id+' and map='+map;
                EIA_grapher.data.geosets[setKey] = eiaData.geoset;
                _mapOptions();
            });
        } else {
            _mapOptions()
        }
        var regionValues;

        function _mapOptions(){
            var myGeoset = EIA_grapher.data.geosets[setKey],
                mapRegions = jvm.Map.maps[map].paths,
                mapLastDate = '',
                mapFirstDate = false,
                uniformStartDate = true,
                regionCode,
                seriesFirstDate,
                seriesLastDate,
                title = _categoriesFromSeries(myGeoset.series),
                maxChange = 0;
            myGeoset.setName = myGeoset.setName || title;
            for(regionCode in myGeoset.series){ //necessary in case not all regions have current data
                //if(mapRegions[regionCode] && myGeoset.series[regionCode].data.length > 0 ){ //don't include tracking regions
                if(myGeoset.series[regionCode].data.length > 0 ){ //don't include tracking regions
                    seriesLastDate = myGeoset.series[regionCode].data[0][0];
                    if(mapLastDate < seriesLastDate) mapLastDate = seriesLastDate;
                    seriesFirstDate = myGeoset.series[regionCode].data[myGeoset.series[regionCode].data.length-1][0];
                    if(!mapFirstDate) mapFirstDate = seriesFirstDate;
                    if( mapFirstDate > seriesFirstDate){
                        mapFirstDate = seriesFirstDate;
                        uniformStartDate = false;
                    }
                }
            }
            regionValues = getRegionSeries(mapRegions, myGeoset, mapLastDate);
            if(analysis=='indexval'){
                var initialRegionValues = getRegionSeries(mapRegions, myGeoset, mapFirstDate),
                    changeValues = {};
                for(regionCode in initialRegionValues){
                    if(typeof regionValues[regionCode] != 'undefined'){
                        for(var decimals=0; decimals<10;decimals++){
                            if(regionValues[regionCode]==regionValues[regionCode].toFixed(decimals) && initialRegionValues[regionCode]==initialRegionValues[regionCode].toFixed(decimals)) break;
                        }
                        changeValues[regionCode] = parseFloat((regionValues[regionCode] - initialRegionValues[regionCode]).toFixed(decimals));
                        maxChange = Math.max(maxChange, Math.abs(changeValues[regionCode]));

                    }
                }
            }
            mapFirstDate = readableDateFromEiaDate(mapFirstDate, myGeoset.f);
            mapLastDate = readableDateFromEiaDate(mapLastDate, myGeoset.f);

            var mapOptions = {
                map: map,
                zoomOnScroll: false,
                title: myGeoset.setname,
                subtitle: mapLastDate,
                backgroundColor: '#ffffff',
                regionStyle: {
                    initial: {
                        fill: '#999999'
                    },
                    selected: {
                        "stroke-width": 2,
                        "stroke": 'yellow',
                        fill: null
                    }
                },
                geosetData: myGeoset,
                series: {
                    regions:  [{
                        values: regionValues,
                        scale: ['#b0efff','#001F37'],
                        legend: {
                            title: myGeoset.units,
                            horizontal: true
                        }
                    }]
                },
                onRegionTipShow: function(e, el, code){
                    if(myGeoset.series[code] && (analysis!='indexval' || typeof changeValues[code] != 'undefined')) {
                        el.html(myGeoset.series[code].name+':<br>'+regionValues[code]+' '+myGeoset.units
                        + (analysis=='indexval' ? '<br>(a change of <b>' + (changeValues[code]>0?'+':'') + changeValues[code]+' '+myGeoset.units + '</b> from ' + mapFirstDate + ' to ' + mapLastDate + ')': '')
                        );
                    }
                }
            };
            if(analysis=='indexval') {
                mapOptions.series.regions[0] = {
                    min: -maxChange,
                    max: maxChange,
                    scale: ['#6F2EA4','#cccccc','#5D9732'],
                    values: changeValues,
                    legend: {
                        title: myGeoset.units,
                        horizontal: true
                    }
                };
                mapOptions.subtitle = 'Change from  ' + mapFirstDate + ' to ' + mapLastDate;

            }
            callback(mapOptions);
        }

        function _makeMap(mapName){ //makes a new map definiation by reconfiguring/merging paths from an existing map
            if(!jvm.Map.maps[mapName]){
                var mapDef = literals.derivedMapDefinitions[mapName];
                jvm.Map.maps[mapName] = $.extend(true, {}, jvm.Map.maps[mapDef.derivedFrom]);
                var newMap = jvm.Map.maps[mapName];
                for(var i=0;i<mapDef.regions.length;i++){
                    var regionDef = mapDef.regions[i];
                    newMap.paths[regionDef.code] = {name: regionDef.name, path: ""};
                    for(var j=0;j<regionDef.components.length;j++){
                        if(newMap.paths[regionDef.components[j]]){
                            newMap.paths[regionDef.code].path += (j==0?'':' ') + newMap.paths[regionDef.components[j]].path;
                        } else {
                            //console.info(regionDef.components[j]+' not found in '+mapDef.derivedFrom);
                        }
                        delete newMap.paths[regionDef.components[j]];
                    }
                }
            }
        }
    }
    function getRegionSeries(mapRegions, myGeoset, mapDate){
        var seriesData,
            jvmRegionSeries = {};
        for(var regionCode in myGeoset.series){
            if(mapRegions && mapRegions[regionCode]){
                seriesData = myGeoset.series[regionCode].data;
                for(var i=0;i<seriesData.length;i++){
                    if(seriesData[i][0]==mapDate){
                        if(seriesData[i][1]!==null && !isNaN(seriesData[i][1])){
                            jvmRegionSeries[regionCode] = seriesData[i][1];
                        }
                        break;
                    }
                }
            }
        }
        return jvmRegionSeries;
    }

    function callAPI(params, callback){
        var command = params.command,//required,
            url = '//' + publicMethods.server_host + '/' +command+'/?w=' + EIA_grapher.version + '&api_key=' + EIA_grapher.api_key + '&out=jsonp&tzOffset='+tzOffset;
		
		params.useCDN = 't';
        for(var param in params){
            if(param!='command') url += '&' + param + '=' + encodeURIComponent(params[param]);
        }
        var startTime = new Date();
        $.ajax({
            url: url,
            crossDomain: true,
            dataType: 'jsonp',
            jsonpCallback: 'apiCallback',
            cache: true,
            success: function(jsoData){
                var returnTime = new Date();
                if(window.console && window.console.info) console.info(command+' api call total round-trip: '+(returnTime.getTime()-startTime.getTime())+'ms');
                callback(jsoData);
            },
            failure: function(jsoData){if(window.console && window.console.info) console.info(jsoData)}
        });
    }

    if(window.Highcharts)
        (function(HC){ //self contained function to protect namespace
/* unused commenting out - SG 10/6/2015
            var InitHighChart_var = {};
            InitHighChart_var.chart_type_supported = ["line", "area", "column", "bar", "pie", "arearange"];
            InitHighChart_var.credits_text = 'Source: Energy Information Administration';
            InitHighChart_var.credits_href = 'http://www.eia.gov';
            InitHighChart_var.chart_type = 'line';
*/
            HC.setOptions({
                chart : {
                    events : {
                        load: function() {
                            var url = this.options.credits.href;
                            this.credits.element.onclick = function(){
                                window.open(
                                    url,
                                    '_blank'
                                );

                                return false;
                            };
                        }
                    }
                },
                credits : {
                    style: {
                        color: '#0096d7',
                        textDecoration: 'underline'
                    }
                },
                plotOptions: {
                    series: {
                        marker: {
                            enabled: false
                        }
                    }
                },
                noData: {

                },
                legend: {
                    y: 20
                },
                exporting: {
                    enabled: false
                }
            });
            var errors = [];	//error messages

            //plot chart based on request object
            HC.wrap(HC.Chart.prototype, 'init', function (proceed, request, callback) {
                var self=this;
                var num = request.eia_num || false; //allow num, start and end to be set in either centrally or series by series
                var start = request.eia_start || false;
                var end = request.eia_end || false;
                var periods = request.eia_periods || false;
                var skey;
                var seriesToFetchIds = [];

                //look for requested EIA series IDs
                var hasEmptyEiaSeries = false; //indicate whether addEiaSeries() needs to be called (whether an API call was needed or the series were available in data series cache
                jQuery.each(request.series,function(index, serie){
                    if(serie.eia_series_id && !serie.data){
                        hasEmptyEiaSeries = true;
                        skey = serie.eia_series_id +':num='+num+':start='+start+':end='+end;  //local storage for reuse needs to account for the potential different date range requests
                        if(!EIA_grapher.data.series[skey]) seriesToFetchIds.push(serie.eia_series_id);
                    }
                });


                if(seriesToFetchIds.length){
                    var params = {command: 'series', series_id: seriesToFetchIds.join(';')};
                    if(start) params.start = start;
                    if(end) params.end = end;
                    if(num) params.num = num;
                    if(periods) params.periods = periods;
                    callAPI(params, addEiaSeries);
                } else {
                    if(hasEmptyEiaSeries) {
                        addEiaSeries();
                    } else {
                        proceed.call(self, request, callback); //if no EIA series to add, directly call Highcharts
                    }
                }

                //MAIN FUNCTION THAT FILLS IN THE DATA
                function addEiaSeries(apiData){
                    //1. save any newly returned series to the shared data store
                    var s, skey, serie, series_id, eia_series;
                    if(typeof apiData !== 'undefined' && apiData.series){
                        for(s=0;s<apiData.series.length;s++){
                            serie = apiData.series[s];
                            skey = serie.series_id +':num='+num+':start='+start+':end='+end;  //local storage for reuse needs to account for the potential different date range requests
                            EIA_grapher.data.series[skey] = apiData.series[s];
                        }
                    }

                    //2. fill series with eia_series_ids but without data from cache
                    for(s=0;s<request.series.length;s++){
                        if(request.series[s].eia_series_id && !request.series[s].data){
                            series_id = request.series[s].eia_series_id;
                            skey = series_id +':num='+num+':start='+start+':end='+end;  //local storage for reuse needs to account for the potential different date range requests
                            if(eia_series = EIA_grapher.data.series[skey]){
                                request.series[s].data =_parseTimeData(eia_series);
                                if(!request.series[s].name) request.series[s].name =  eia_series.name;
                                //make sure the units have a yAxis and that it is used for this series
                                if(!request.yAxis) request.yAxis = [];
                                var axisExists = false;
                                for(var i=0;i<request.yAxis.length;i++){
                                    if(request.yAxis[i].title && request.yAxis[i].title.text==eia_series.units) {
                                        axisExists = true;
                                        break;
                                    }
                                }
                                if(axisExists){
                                    request.series[s].yAxis = i;
                                } else {
                                    request.yAxis.push({title: {text: eia_series.units}});
                                    request.series[s].yAxis = i;  //which is = old length = new length -1
                                }
                            }
                        }
                    }

                    //request.title = request.title || { text: chart_title	}; //set title based on setting
                    request.lang = request.lang || { noData: "No data" };
                    request.noData = request.noData || {  //default Highcharts message if no data available
                        style: {
                            fontWeight: 'bold',
                            fontSize: '15px',
                            color: '#303030'
                        }
                    };
                    request.tooltip = request.tooltip || {
                        crosshairs: true,
                        useHTML: true,
                        pointFormat: "{series.name}: <b>{point.y}</b><br/>"
                    };

                    request.xAxis = request.xAxis || { type: 'datetime'	};	//set xaxis options
                    proceed.call(self, request, callback);


                    function _parseTimeData(eia_series){
                        //put that thing down, slice() it and reverse() it
                        var series_data_arr = eia_series.data.slice(0).reverse(),
                            point, convertedDate, j, y;

                        var datetime_value = []; //init array of converted datetime values
                        for (j=0;j<series_data_arr.length;++j) { //for each point in the series
                            point = String(series_data_arr[j]).split(','); //init individual point array
                            convertedDate = utcDateFromEiaDate(point[0]);
                            y = point[1];
                            datetime_value.push([convertedDate, isNaN(y)? null : parseFloat(y)]);
                        }
                        return datetime_value;
                    }
                }
            });


            /**
             * Javascript utility supportive functions
             */

                //convert number to comma formatted number - as money format
            function numberWithCommas(x) {
                var parts = x.toString().split(".");
                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                return parts.join(".");
            }

            function escapeRegExp(string) {
                return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
            }

            //adding JavaScript trim() if not available : specially for IE browser
            if(typeof String.prototype.trim !== 'function') {
                String.prototype.trim = function() {
                    return this.replace(/^\s+|\s+$/g, '');
                }
            }

        }(Highcharts));

    function utcDateFromEiaDate(eiaDate, localTime){
        if(typeof eiaDate != 'string') {
            eiaDate = eiaDate.toString();
        }
        var theYear, theMonth, theDay, theHour;
        theYear = Number(eiaDate.substr(0,4));
        theMonth = Number(eiaDate.length >= 6 ? (  // must handle quarterly dates too
            eiaDate.substr(4,1) == 'Q'?3*(parseInt(eiaDate.substr(5,1))-1)+1:eiaDate.substr(4,2)
            ):'01');
        theDay = Number(eiaDate.length >= 8 ? eiaDate.substr(6,2) : '01');
        theHour = Number(eiaDate.length == 12 ? eiaDate.substr(9,2) : '00');
        return localTime ? new Date(parseInt(theYear), parseInt(theMonth)-1, parseInt(theDay), parseInt(theHour)) : Date.UTC(parseInt(theYear), parseInt(theMonth)-1, parseInt(theDay), parseInt(theHour));
    }

    function readableDateFromUtcDate(utcDate, freq){  //used in tool tips
        var utcYear = utcDate.getUTCFullYear(),
            utcMonth = utcDate.getUTCMonth(),
            utcDay = utcDate.getUTCDate(),
            utcHour = utcDate.getUTCHours();
        switch(freq||'D'){
            case 'A':
                return utcYear;
            case 'Q':
                return utcYear+'-Q'+(Math.floor(utcMonth/3)+1);
                break;
            case 'M':
                return utcYear+'-'+(utcMonth<9?'0':'')+(utcMonth+1);
            case 'H':
                return  utcYear+'-'+(utcMonth<9?'0':'')+(utcMonth+1)+'-'+(utcDay<10?'0':'')+utcDay+' '+(utcHour<10?'0':'')+utcHour+'H';
            default:  //weekly, daily and undefined
                return utcYear+'-'+(utcMonth<9?'0':'')+(utcMonth+1)+'-'+(utcDay<10?'0':'')+utcDay;
        }
    }
    function readableDateFromEiaDate(eiaDate, frequency){
        if(typeof eiaDate != 'string') {
            eiaDate = eiaDate.toString();
        }
        var theYear, theMonthQuarter, theDay, theHour;

        var ret = '';

        theYear = eiaDate.substr(0,4);
        theMonthQuarter = eiaDate.substr(4,2);
        theDay = eiaDate.substr(6,2);
        theMonthQuarter = eiaDate.length >= 6
            ? (eiaDate.substr(4,1) == 'Q'?eiaDate.substr(4,2): literals.monthNames[parseInt(eiaDate.substr(4,2))])// must handle quarterly dates too
            :'';
        theDay = eiaDate.length >= 8 ? eiaDate.substr(6,2) : '';
        theHour = eiaDate.length >= 12 ? eiaDate.substr(9,2) : '';

        switch(frequency.toUpperCase()) {
            case 'W':
                ret = 'Week of ' + theMonthQuarter + ' ' + parseInt(theDay) + ', ' + parseInt(theYear);
                break;
            case 'H':
                ret = theMonthQuarter + ' ' + parseInt(theDay) + ', ' + parseInt(theYear) + ' ' + parseInt(theHour) + 'H';
                break;
            case 'Q':
                ret = theMonthQuarter + ' ' + parseInt(theYear);
                break;
            case 'M':
                ret = theMonthQuarter + ' ' + parseInt(theYear);
                break;
            case 'D':
                ret = theMonthQuarter + ' ' + parseInt(theDay) + ', ' + parseInt(theYear);
                break;
            case 'A':
                ret = parseInt(theYear);
                break;
            case '4':
                ret = '4-week average ending ' + theMonthQuarter + ' ' + parseInt(theDay) + ', ' + parseInt(theYear);
                break;
            default:
                ret = theDay + theMonthQuarter + theYear;
        }

        return ret.toString();
    }

    function parseEiaTimeSeriesData(data){
        var x, i, parsedData = null;
        if(data!==null){
            parsedData = [];
            for(i=0;i<data.length;i++){
                x = data[i][0];
                if(x.length){
                    parsedData.push([utcDateFromEiaDate(x), data[i][1]]);
                }
            }
            parsedData.sort(function(a,b){return a[0] - b[0]});
        }
        return parsedData;
    }

    function _showRegionSeries(relationChart, geosetData, regionCode){
        // relationChart is either a chart object or a integer width
        if(typeof geosetData.series[regionCode] === 'undefined') return {};
        var seriesOptions = {
            data: parseEiaTimeSeriesData(geosetData.series[regionCode].data),
            id: regionCode,
            name: _breakInsert(geosetData.series[regionCode].categoryName||geosetData.series[regionCode].name, isNaN(relationChart)?$(relationChart.container).width(): relationChart)
        };
        if(isNaN(relationChart)) { //if chart object is provided, add the series
            var colors ={}; // make hard copy
            for(var i = 0; i < relationChart.options.colors.length; i++) {
                colors[relationChart.options.colors[i]] = 0;
            }
            for(var i = 0; i < relationChart.series.length; i++) {
                colors[relationChart.series[i].color] = (isNaN(colors[relationChart.series[i].color]) ? 0 : colors[relationChart.series[i].color]) + 1;
            }
            var min = Infinity;
            for(var color in colors) {
                if(colors[color] < min) {
                    min = colors[color];
                    seriesOptions.color = color;
                }
            }
            relationChart.addSeries(seriesOptions);
        }
        return seriesOptions;
    }
    function _categoriesFromSeries(series){ //returns an array of the unique word cores from the series' names, stripping off common words from the beginning and ends of the string
        var s, nonNullSeries;
        //create the local list
        for(s in series){
            if(series[s].name) {
                series[s].categoryName = series[s].name.split(' ');
                nonNullSeries = series[s];
            }
            //coredNames.push(series[i].name);
        }
        var titleStartWords = _removeCommonStartWords();
        _reverse(); //reverse order so we can from common words from the end of the series name
        var titleEndWords = _removeCommonStartWords();
        _reverse(true);  //reverse again = normal order and rejoin array into a string
        return titleStartWords.concat(titleEndWords.reverse()).join(' ');

        function _removeCommonStartWords(){
            var s, word, isCommon, titleWords = [];
            while(nonNullSeries.categoryName.length){
                word = nonNullSeries.categoryName[0];
                isCommon = true;
                for(s in series){
                    if(series[s].categoryName && series[s].categoryName[0]!=word) {
                        isCommon = false;
                        break;
                    }
                }
                if(isCommon){
                    titleWords.push(word);
                    for(s in series){
                        if(series[s].categoryName) series[s].categoryName.shift();
                    }
                } else {
                    break;
                }
            }
            return titleWords;
        }
        function _reverse(rejoinToString){
            for(var s in series){
                if(series[s].categoryName){
                    series[s].categoryName.reverse();
                    if(rejoinToString) {
                        series[s].categoryName = series[s].categoryName.join(' ');
                        while(nonWordPat.test(series[s].categoryName.substr(-1,1)))
                            series[s].categoryName = series[s].categoryName.substr(0, series[s].categoryName.length - 1);  //remove trailing spaces and punctuation
                    }
                }
            }
        }
    }
    function _seriesValue(data, date){
        var point, i;
        if(data) {
            if(date){
                for(i=0;i<data.length;i++){
                    point = data[i];
                    if(point[0]==date){
                        return point[1];
                    }
                }
            } else {
                point = data[0];  //EIA returns series data in reverse chronological order
                if(point) return point[1];
            }
        }
        return undefined;
    }
    function _linkBackUrl(ids){
        var dataset = ids.split('.')[0];
        return 'http://www.eia.gov' + (literals.dataset_urls[dataset] || '') + '?src=apiviz';
    }
    function _breakInsert(label, chartWidth){ //used to insert line break <br> into series and category names likely to overflow
        var pointsPerChar = 500/70;  //approximate average points per char
        var margins = 0;
        var maxChars = (chartWidth-margins)/pointsPerChar;
        if(label.length>maxChars){
            var firstLine = label.split(' '), secondLine = [];
            while(firstLine.join(' ').length>maxChars){
                secondLine.unshift(firstLine.pop());
            }
            firstLine = firstLine.join(' ');
            secondLine = secondLine.join(' ');
            secondLine = _breakInsert(secondLine, chartWidth);  //break again if necessary
            label = firstLine + '<br> ' + secondLine;
        }
        return label;
    }
    function visualizationReady($eiaVisualization, fetchedData, type, optionsObject){//overwrite EIA_grapher.visualizationComplete with custom callback if needed to provide post data fetch processing or map/chart optionsObject modification
        // $eiaVisualization: jQuery object of the visualization DIV for this callback
        // fetchedData:  the series, relation, or geoset data object returned (will be null for interactive map-chart with mouse-over interaction that do not fetched supplemental data)
        // type = 'chart' or 'map' or 'relation' string literal
        // optionsObject: depending on type, will be an assembled Highcharts options object or a jVectormap options object, prior to drawing the graph or map
    }

    //returned functions are public functions
    var publicMethods =  {
        version: 0.6,
        drawAllVisualizations: drawAllVisualizations,
        drawDivVisualization: drawDivVisualization,
        makeMapOptions: makeMapOptions,
        makeRelationChartOptions: makeRelationChartOptions,
        parseEiaTimeSeriesData: parseEiaTimeSeriesData,
        literals: literals,
        utcDateFromEiaDate: utcDateFromEiaDate,
        readableDateFromEiaDate: readableDateFromEiaDate,
        api_key: '', //'API_KEY_REQUIRED',
        server_host: document.location.hostname=='wwwdev.eia.gov' ? 'apidev.eia.gov' : 'api.eia.gov',
        data: {
            geosets: {},
            series: {},
            relations: {}
        },
        visualizationReady: visualizationReady //overwrite EIA_grapher.visualizationComplete with custom callback if needed to provide post data fetch processing or map/chart optionsObject modification
        // visualizationReady input parameters:
        //   $eiaVisualization: jQuery object of the visualization DIV for this callback
        //   data:  the series, relation, or geoset data object returned
        //   type = 'chart' or 'map' or 'relation' string literal
        //   optionsObject: depending on type, will be an assembled Highcharts options object or a jVectormap options object, prior to drawing the graph or map
    };
    return publicMethods;

}();
if(typeof window.onReady == 'function') {
    window.onReady.apply(window);
}
$(document).ready(function(){
    jQuery.support.cors = true;
    EIA_grapher.drawAllVisualizations();
});


